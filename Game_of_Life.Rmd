---
title: "Cellular_automata_2D(Game of Life)"
output: rmarkdown::github_document
date: '2022-07-13'
---

# Objective

As we have briefly investigated 1d elementary cellular automata (CA), we will now move to the 2D part and hopefully create some cool patterns! Game of life here we come!


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(magick)
library(magrittr)
```

```{r include=FALSE}
## Display the grid
save <- function(mat, path, iter){
  png(paste0(path,sprintf("%05d",iter), ".png", collapse = ""))
  par(mar = c(1,1,2,1), pty = "m") 
  image(t(apply(mat,2,rev)), col=c("grey90", "grey40"), yaxt="n", xaxt="n")
  grid(nx = ncol(mat), ny = nrow(mat),col="grey70", lty=1)
  title(main = paste0("Game of Life", collapse = ""))
  dev.off()
}
```

```{r include=FALSE}
## Display the grid
display <- function(mat){
  par(pty = "s") 
  image(t(apply(mat,2,rev)), col=c("grey90", "grey40"), yaxt="n", xaxt="n")
  grid(nx = ncol(mat), ny = nrow(mat),col="grey70", lty=1)
  title(main = paste0("Game of Life", collapse = ""))

}
```

```{r include=FALSE}
## Initialize a matrix with fixed starting point(middle of 2D array)
init <- function(n){
  mat = matrix(0,nrow=n, ncol=n)
  # mat[1,ceiling(n)]=1
  return (mat)
}
```

## Game of Life

Invented by John Conway in 1970s, this two-state, 2D CA has the following rules: 

* Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.
* Any live cell with two or three live neighbours lives on to the next generation.
* Any live cell with more than three live neighbours dies, as if by overpopulation.
* Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.


Here, a neighbour is defined as the all 8 cells surrounding the center cell. This is called Moore neighborhood.

```{r}
GoL <- function(mat, path, iter){
  save(mat, path, 0)
  for (k in 1:iter) {
    temp_mat = matrix(0,nrow(mat), ncol(mat))
    for (i in 1:ncol(mat)){
      for (j in 1:nrow(mat)){
        N = j-1
        S = j+1
        E = i+1
        W = i-1
        # for wrap around effect
        if (N == 0) {N = nrow(mat)}
        if (S == nrow(mat) + 1) {S = 1}
        if (E == ncol(mat) + 1) {E = 1}
        if (W == 0) {W = ncol(mat)}
        # check number of adjacent live cells
        count_lives = mat[N,i] + mat[S,i] + mat[j,E] + mat[j,W] + mat[N,W] + mat[N,E] + mat[S,W] + mat[S,E]
        if (mat[j,i] == 1 && count_lives < 2)                     {temp_mat[j,i] = 0}
        if (mat[j,i] == 1 && (count_lives == 2|| count_lives == 3)){temp_mat[j,i] = 1}
        if (mat[j,i] == 1 && count_lives > 3)                     {temp_mat[j,i] = 0}
        if (mat[j,i] == 0 && count_lives == 3)                    {temp_mat[j,i] = 1}
      }
    }
    mat = temp_mat
    save(mat, path, k)
  }
}
```

## Oscillators

These are some patterns that will repeat itself after a certain number of iterations.

They come from different initial states

```{r echo=TRUE}
## Initialization of oscillators

# mat_size = 17
# mat=init(mat_size)
# # Blinker
# mat[2:4,3] = 1

# # Toad
# mat[3,3:5] = 1 
# mat[4,2:4] = 1

# # Beacon 
# mat[2:3,2:3] = 1
# mat[4:5,4:5] = 1

# # Pulsar
# mat[c(3,8), 5:7] = 1
# mat[5:7, c(3,8)] = 1
# tmp = t(apply(mat, 2, rev)) # rotating pattern for 90 degrees
# tmp2 = t(apply(tmp, 2, rev))
# tmp3 = t(apply(tmp2, 2, rev))
# mat = mat+tmp+tmp2+tmp3

# # Pentadecathlon
# mat[6:15,11] = 1

```

| | | 
| :---: | :---: |
|![Blinker](https://media0.giphy.com/media/yRS6RJr9N8JiuzVmna/200w.webp)Blinker|![Toad](https://media1.giphy.com/media/NfvVwnUyU6Zg5jWlfA/200w.webp)Toad|
|![Beacon](https://media4.giphy.com/media/8PcqPIPXbRK50qUef1/200w.webp)Beacon|![Pulsar](https://media1.giphy.com/media/jHPa8vcy3zMmnWVhkN/200w.webp)Pulsar|

![pentadecathlon](https://media2.giphy.com/media/nBslXi3zOBM44x6KlJ/giphy.gif?cid=790b7611a378b629621a62794dfacca17024d0212aea497f&rid=giphy.gif&ct=g)
Pentadecathlon

## Spaceships

These are many patterns that will move across the screen. 4 of the most common ones will be shown below.

```{r echo=TRUE}
## Initialization of spaceships

mat_size = 21
mat = init(mat_size)

# Glider
glider = cbind(c(2,3,4,4,4), c(3,4,2,3,4))

# lightweight spaceship (LWSS)
lwss = cbind(c(2,2,3,4,4,5,5,5,5), c(3,6,7,3,7,4,5,6,7))

# midweight spaceship (MWSS)
mwss = cbind(c(2,3,3,4,5,5,6,6,6,6,6), c(5,3,7,8,3,8,4,5,6,7,8))

# heavytweight spaceship (HWSS)
hwss = cbind(c(2,2,3,3,4,5,5,6,6,6,6,6,6), c(5,6,3,8,9,3,9,4,5,6,7,8,9))

# F-pentomino
Fpen = cbind(c(2,2,3,3,4),c(3,4,2,3,3))



pattern = hwss

mat[pattern + (mat_size/2-1)] = 1

```

The simplest form of spaceship is ***Glider***. This 5 pixel pattern will repeat itself every 4 iterations and it will go on forever!

![glider](https://media1.giphy.com/media/Utz2aofGKqNAXk0CZQ/giphy.gif?cid=790b76114e7a8dc5478069b298c1677bfb33233272a3dfe6&rid=giphy.gif&ct=g)

Below are three different sizes of spaceships! Light, medium, and heavy.

| | | |
| :---: | :---: | :---: |
|![lwss](https://media3.giphy.com/media/zWti5Ka2E0CI2xMYiy/giphy.gif)Light|![mwss](https://media3.giphy.com/media/r1HJ2O1mbxiAh44AmO/giphy.gif)Medium|![hwss](https://media0.giphy.com/media/xEm8H7H0qokPE2WqJZ/giphy.gif)Heavy|



```{r eval=FALSE, include=FALSE}
## This block is used to make gifs, not shown

make_gif <- function(path, gif_name){
list.files(path = path, pattern = "*.png", full.names = T) %>%
  image_read() %>%
  image_join() %>% 
  image_animate(fps=10, delay = 10) %>% 
  image_write(paste0(path,"/",gif_name,".gif", collapse = ""))
}

GoL(mat, "/Volumes/MyBook_3/git/R-random-spontaneous-projects/Game_of_Life_files/spaceship/hwss//",100)
make_gif("/Volumes/MyBook_3/git/R-random-spontaneous-projects/Game_of_Life_files/spaceship/hwss//", "hwss")
```




